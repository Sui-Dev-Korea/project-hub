name: doc-size-done-report

on:
  workflow_dispatch: {}

permissions:
  contents: read
  issues: read
  pull-requests: read
  repository-projects: read

env:
  TZ: Asia/Seoul
  BOT_NAME: reviewer
  GH_TOKEN: ${{ secrets.BOT_TOKEN }}

jobs:
  size-by-assignee:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install tools
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq
          curl -sSL https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64 -o /usr/local/bin/yq
          chmod +x /usr/local/bin/yq

      - name: Ensure gh auth
        run: |
          set -euo pipefail
          if [ -z "${GH_TOKEN:-}" ] && [ -n "${GITHUB_TOKEN:-}" ]; then
            export GH_TOKEN="${GITHUB_TOKEN}"
          fi
          if gh auth status >/dev/null 2>&1; then
            exit 0
          fi
          if [ -z "${GH_TOKEN:-}" ]; then
            echo "GH_TOKEN/GITHUB_TOKEN is required" >&2
            exit 1
          fi
          gh auth login --with-token <<<"${GH_TOKEN}"

      - name: Report Done card doc sizes by assignee
        run: |
          set -euo pipefail

          ls ".github/config/${BOT_NAME}/"*.yml 2>/dev/null | sed 's#.*/##; s#\.yml$##' > projects.txt || true
          COUNT=$(wc -l < projects.txt | tr -d ' ')
          if [ "$COUNT" -eq 0 ]; then
            echo "No configs under .github/config/${BOT_NAME} — nothing to scan."
            exit 0
          fi

          printf '## Done cards: md/mdx size by assignee\n\n' >> "$GITHUB_STEP_SUMMARY"
          printf '|Project|Assignee|Files|Total (KB)|Total (bytes)|Share (%)|\n' >> "$GITHUB_STEP_SUMMARY"
          printf '|-|-|-|-|-|-|\n' >> "$GITHUB_STEP_SUMMARY"

          while read -r KEY; do
            [ -z "$KEY" ] && continue
            echo "::group::Project = $KEY"

            CFG=".github/config/${BOT_NAME}/${KEY}.yml"
            ORG=$(yq -r '.project_org // ""' "$CFG")
            NUM=$(yq -r '.project_number // ""' "$CFG")
            if [ -z "$ORG" ] || [ -z "$NUM" ]; then
              echo "[ERR] project_org/number missing in $CFG"
              exit 1
            fi

            Q_ID='query($org:String!,$num:Int!){
              organization(login:$org){
                projectV2(number:$num){
                  id title
                }
              }
            }'
            PROJECT_ID=$(jq -nc --arg q "$Q_ID" --arg org "$ORG" --argjson num "$NUM" \
              '{query:$q,variables:{org:$org,num:$num}}' \
            | gh api graphql --input - \
            | jq -r '.data.organization.projectV2.id // empty')
            if [ -z "$PROJECT_ID" ]; then
              echo "[ERR] Failed to resolve Project ID for $ORG #$NUM"
              exit 1
            fi

            # Status/Assignee 필드 정보 조회
            FQ='query($pid:ID!){
              node(id:$pid){
                ... on ProjectV2{
                  fields(first:50){
                    nodes{
                      __typename
                      ... on ProjectV2Field { id name dataType }
                      ... on ProjectV2SingleSelectField { id name options { name } }
                    }
                  }
                }
              }
            }'
            jq -nc --arg q "$FQ" --arg pid "$PROJECT_ID" \
              '{query:$q, variables:{pid:$pid}}' \
            | gh api graphql --input - > fields.json

            STATUS_OPTS_JSON=$(jq -c '
              [.data.node.fields.nodes[]
               | select((.name|test("(?i)^status\\s*$")) and .__typename=="ProjectV2SingleSelectField")
               | .options[].name
               | (.| gsub("^\\s+|\\s+$";"") | ascii_downcase)
              ]
            ' fields.json)
            HAS_DONE=$(printf "%s" "$STATUS_OPTS_JSON" | jq 'index("done")')
            if [ "$HAS_DONE" = "null" ]; then
              echo "No Status option matching Done — skip $KEY"
              echo "::endgroup::"
              continue
            fi

            READ_Q='query($pid:ID!,$after:String){
              node(id:$pid){
                ... on ProjectV2{
                  items(first:50, after:$after){
                    pageInfo{ hasNextPage endCursor }
                    nodes{
                      id
                      content{
                        __typename
                        ... on DraftIssue { title body }
                        ... on Issue { title body url repository { nameWithOwner } }
                        ... on PullRequest { title body url repository { nameWithOwner } }
                      }
                      fieldValues(first:100){
                        nodes{
                          __typename
                          ... on ProjectV2ItemFieldSingleSelectValue {
                            name
                            field { ... on ProjectV2Field { name } }
                          }
                          ... on ProjectV2ItemFieldUserValue {
                            field { ... on ProjectV2Field { name } }
                            users(first:50){ nodes{ login } }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }'

            echo '{"data":{"node":{"items":{"nodes":[]}}}}' > proj.json
            AFTER=""
            while :; do
              jq -nc --arg q "$READ_Q" --arg pid "$PROJECT_ID" --arg after "$AFTER" \
                '{query:$q, variables:{pid:$pid, after:($after | if length>0 then . else null end)}}' \
              | gh api graphql --input - > page.json

              jq --slurpfile p page.json '
                .data.node.items.nodes += ($p[0].data.node.items.nodes)
              ' proj.json > _tmp.json && mv _tmp.json proj.json

              HAS_NEXT=$(jq -r '.data.node.items.pageInfo.hasNextPage' page.json)
              AFTER=$(jq -r '.data.node.items.pageInfo.endCursor // ""' page.json)
              [ "$HAS_NEXT" = "true" ] || break
            done
            rm -f page.json

            jq -r --argjson sopts "${STATUS_OPTS_JSON:-[]}" '
              .data.node.items.nodes[]
              | select(.content != null)
              | {id, type: .content.__typename, title: .content.title, body: .content.body, url: .content.url, repo: .content.repository.nameWithOwner, fields: .fieldValues.nodes}
              | (
                  [ .fields[]
                    | select(.__typename=="ProjectV2ItemFieldSingleSelectValue")
                    | (.name // "" | gsub("^\\s+|\\s+$";"") | ascii_downcase)
                    | select(. != "" and ($sopts | index(.)))
                  ]
                ) as $status_vals
              | select(($status_vals | index("done")) != null)
              | (
                  [ .fields[]
                    | select(.__typename=="ProjectV2ItemFieldUserValue")
                    | (.users.nodes[]?.login // empty)
                  ] | unique
                ) as $assignees
              | {id, type, title, body, url, repo, assignees}
              | @base64
            ' proj.json > items.b64

            declare -A P_BYTES=()
            declare -A P_FILES=()

            if [ ! -s items.b64 ]; then
              echo "No Done items found — $KEY"
            fi

            while read -r ROW; do
              [ -z "$ROW" ] && continue
              J=$(echo "$ROW" | base64 -d)
              TITLE=$(echo "$J" | jq -r '.title // ""' | tr '\r\n' ' ')
              BODY=$(echo "$J" | jq -r '.body // ""')
              TYPE=$(echo "$J" | jq -r '.type // ""')
              URL=$(echo "$J" | jq -r '.url // ""')
              REPO=$(echo "$J" | jq -r '.repo // ""')

              LINK=$(printf "%s\n" "$BODY" | grep -Eo 'https://github.com/[^ )]+' | head -n1 || true)
              if [ -z "$LINK" ]; then
                echo "Skip (no link) :: $TITLE"
                continue
              fi
              if ! echo "$LINK" | grep -qiE '\.(md|mdx)($|[?#])'; then
                echo "Skip (not md/mdx) :: $LINK"
                continue
              fi

              RAW_URL="$LINK"
              if echo "$LINK" | grep -q '/blob/'; then
                RAW_URL=$(printf "%s" "$LINK" | sed 's#https://github.com/#https://raw.githubusercontent.com/#; s#/blob/#/#')
              fi

              HDR=()
              if [ -n "${GH_TOKEN:-}" ]; then
                HDR=(-H "Authorization: Bearer ${GH_TOKEN}")
              elif [ -n "${GITHUB_TOKEN:-}" ]; then
                HDR=(-H "Authorization: Bearer ${GITHUB_TOKEN}")
              fi

              if ! curl -sSL "${HDR[@]}" "$RAW_URL" -o tmp.md; then
                echo "Fetch failed :: $RAW_URL"
                continue
              fi

              BYTES=$(wc -c < tmp.md | tr -d ' ')
              FILE_NAME=$(basename "$LINK")
              rm -f tmp.md

              mapfile -t ASSIGNEES < <(echo "$J" | jq -r '.assignees[]?')
              # Fallback 1: Issue/PR assignees (API)
              if [ ${#ASSIGNEES[@]} -eq 0 ] && { [ "$TYPE" = "Issue" ] || [ "$TYPE" = "PullRequest" ]; }; then
                NUM=$(basename "$URL")
                if [ -n "$NUM" ] && [ -n "$REPO" ]; then
                  mapfile -t ASSIGNEES < <(gh api repos/"$REPO"/issues/"$NUM" --jq '.assignees[].login' 2>/dev/null || true)
                fi
              fi
              # Fallback 2: Text field named like Assignee(s)
              if [ ${#ASSIGNEES[@]} -eq 0 ]; then
                mapfile -t ASSIGNEES < <(echo "$J" | jq -r '
                  .fields[]?
                  | select(.__typename=="ProjectV2ItemFieldTextValue")
                  | select((.field.name // "" | test("(?i)assignee")))
                  | (.text // "")
                ' | tr '@' ' ' | tr ',' ' ' | tr '\n' ' ' | tr '\r' ' ' | tr ' ' '\n' | sed '/^$/d' | sort -u)
              fi
              if [ ${#ASSIGNEES[@]} -eq 0 ]; then
                ASSIGNEES=("unassigned")
              fi

              for A in "${ASSIGNEES[@]}"; do
                A=$(printf "%s" "$A" | tr -d '\r\n' | sed 's/^@//')
                [ -z "$A" ] && continue
                P_BYTES[$A]=$(( ${P_BYTES[$A]:-0} + BYTES ))
                P_FILES[$A]=$(( ${P_FILES[$A]:-0} + 1 ))
              done

              echo "Done :: $TITLE | $FILE_NAME | bytes=$BYTES | assignee(s)=$(printf "%s" "${ASSIGNEES[*]}")"
            done < items.b64

            if [ ${#P_BYTES[@]} -eq 0 ]; then
              printf '|%s|%s|%s|%s|%s|%s|\n' "$KEY" "-" "0" "0.0" "0" "0.0" >> "$GITHUB_STEP_SUMMARY"
              echo "::endgroup::"
              continue
            fi

            # Project totals
            TOTAL_BYTES=0
            TOTAL_FILES=0
            for USER in "${!P_BYTES[@]}"; do
              TOTAL_BYTES=$(( TOTAL_BYTES + ${P_BYTES[$USER]} ))
              TOTAL_FILES=$(( TOTAL_FILES + ${P_FILES[$USER]} ))
            done
            TOTAL_KB=$(awk "BEGIN { printf \"%.1f\", $TOTAL_BYTES/1024 }")
            printf '|%s|%s|%s|%s|%s|%s|\n' "$KEY" "TOTAL" "$TOTAL_FILES" "$TOTAL_KB" "$TOTAL_BYTES" "100.0" >> "$GITHUB_STEP_SUMMARY"

            for USER in "${!P_BYTES[@]}"; do
              B=${P_BYTES[$USER]}
              F=${P_FILES[$USER]}
              KB=$(awk "BEGIN { printf \"%.1f\", $B/1024 }")
              SHARE=$(awk "BEGIN { if ($TOTAL_BYTES==0) print \"0.0\"; else printf \"%.1f\", ($B*100)/$TOTAL_BYTES }")
              printf '|%s|%s|%s|%s|%s|%s|\n' "$KEY" "$USER" "$F" "$KB" "$B" "$SHARE" >> "$GITHUB_STEP_SUMMARY"
            done

            echo "::endgroup::"
          done < projects.txt
