name: doc-size-done-report

on:
  workflow_dispatch: {}

permissions:
  contents: read
  issues: read
  pull-requests: read
  repository-projects: read

env:
  TZ: Asia/Seoul
  BOT_NAME: reviewer
  GH_TOKEN: ${{ secrets.BOT_TOKEN }}

jobs:
  size-by-assignee:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install tools
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq
          curl -sSL https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64 -o /usr/local/bin/yq
          chmod +x /usr/local/bin/yq

      - name: Ensure gh auth
        run: |
          set -euo pipefail
          if [ -z "${GH_TOKEN:-}" ] && [ -n "${GITHUB_TOKEN:-}" ]; then
            export GH_TOKEN="${GITHUB_TOKEN}"
          fi
          if gh auth status >/dev/null 2>&1; then
            exit 0
          fi
          if [ -z "${GH_TOKEN:-}" ]; then
            echo "GH_TOKEN/GITHUB_TOKEN is required" >&2
            exit 1
          fi
          gh auth login --with-token <<<"${GH_TOKEN}"

      - name: Report Done card doc sizes by assignee
        run: |
          set -euo pipefail

          ls ".github/config/${BOT_NAME}/"*.yml 2>/dev/null | sed 's#.*/##; s#\.yml$##' > projects.txt || true
          COUNT=$(wc -l < projects.txt | tr -d ' ')
          if [ "$COUNT" -eq 0 ]; then
            echo "No configs under .github/config/${BOT_NAME} — nothing to scan."
            exit 0
          fi

          ASSIGNEE_ROWS="$(mktemp)"
          REVIEWER_ROWS="$(mktemp)"
          PROGRESS_ROWS="$(mktemp)"
          SUMMARY_OUT="$(mktemp)"
          cleanup() { rm -f "$ASSIGNEE_ROWS" "$REVIEWER_ROWS" "$PROGRESS_ROWS" "$SUMMARY_OUT"; }
          trap cleanup EXIT

          SUI_TOTAL_DOC_BYTES=""

          while read -r KEY; do
            [ -z "$KEY" ] && continue
            echo "::group::Project = $KEY"

            CFG=".github/config/${BOT_NAME}/${KEY}.yml"
            ORG=$(yq -r '.project_org // ""' "$CFG")
            NUM=$(yq -r '.project_number // ""' "$CFG")
            if [ -z "$ORG" ] || [ -z "$NUM" ]; then
              echo "[ERR] project_org/number missing in $CFG"
              exit 1
            fi

            Q_ID='query($org:String!,$num:Int!){
              organization(login:$org){
                projectV2(number:$num){
                  id title
                }
              }
            }'
            PROJECT_ID=$(jq -nc --arg q "$Q_ID" --arg org "$ORG" --argjson num "$NUM" \
              '{query:$q,variables:{org:$org,num:$num}}' \
            | gh api graphql --input - \
            | jq -r '.data.organization.projectV2.id // empty')
            if [ -z "$PROJECT_ID" ]; then
              echo "[ERR] Failed to resolve Project ID for $ORG #$NUM"
              exit 1
            fi

            # Status/Assignee 필드 정보 조회
            FQ='query($pid:ID!){
              node(id:$pid){
                ... on ProjectV2{
                  fields(first:50){
                    nodes{
                      __typename
                      ... on ProjectV2Field { id name dataType }
                      ... on ProjectV2SingleSelectField { id name options { name } }
                    }
                  }
                }
              }
            }'
            jq -nc --arg q "$FQ" --arg pid "$PROJECT_ID" \
              '{query:$q, variables:{pid:$pid}}' \
            | gh api graphql --input - > fields.json

            STATUS_OPTS_JSON=$(jq -c '
              [.data.node.fields.nodes[]
               | select((.name|test("(?i)^status\\s*$")) and .__typename=="ProjectV2SingleSelectField")
               | .options[].name
               | (.| gsub("^\\s+|\\s+$";"") | ascii_downcase)
              ]
            ' fields.json || echo "[]")
            [ -n "$STATUS_OPTS_JSON" ] || STATUS_OPTS_JSON="[]"
            if ! printf "%s" "$STATUS_OPTS_JSON" | jq empty >/dev/null 2>&1; then
              STATUS_OPTS_JSON="[]"
            fi
            HAS_DONE=$(printf "%s" "$STATUS_OPTS_JSON" | jq 'index("done")' 2>/dev/null || echo "null")
            if [ "$HAS_DONE" = "null" ]; then
              echo "No Status option matching Done — skip $KEY"
              echo "::endgroup::"
              continue
            fi

            READ_Q='query($pid:ID!,$after:String){
              node(id:$pid){
                ... on ProjectV2{
                  items(first:50, after:$after){
                    pageInfo{ hasNextPage endCursor }
                    nodes{
                      id
                      content{
                        __typename
                        ... on DraftIssue { title body }
                        ... on Issue { title body url repository { nameWithOwner } }
                        ... on PullRequest { title body url repository { nameWithOwner } }
                      }
                      fieldValues(first:100){
                        nodes{
                          __typename
                          ... on ProjectV2ItemFieldSingleSelectValue {
                            name
                            field { ... on ProjectV2Field { name } }
                          }
                          ... on ProjectV2ItemFieldTextValue {
                            text
                            field { ... on ProjectV2Field { name } }
                          }
                          ... on ProjectV2ItemFieldUserValue {
                            field { ... on ProjectV2Field { name } }
                            users(first:50){ nodes{ login } }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }'

            echo '{"data":{"node":{"items":{"nodes":[]}}}}' > proj.json
            AFTER=""
            while :; do
              jq -nc --arg q "$READ_Q" --arg pid "$PROJECT_ID" --arg after "$AFTER" \
                '{query:$q, variables:{pid:$pid, after:($after | if length>0 then . else null end)}}' \
              | gh api graphql --input - > page.json

              jq --slurpfile p page.json '
                .data.node.items.nodes += ($p[0].data.node.items.nodes)
              ' proj.json > _tmp.json && mv _tmp.json proj.json

              HAS_NEXT=$(jq -r '.data.node.items.pageInfo.hasNextPage' page.json)
              AFTER=$(jq -r '.data.node.items.pageInfo.endCursor // ""' page.json)
              [ "$HAS_NEXT" = "true" ] || break
            done
            rm -f page.json

            jq -r --argjson sopts "${STATUS_OPTS_JSON:-[]}" '
              .data.node.items.nodes[]
              | select(.content != null)
              | {id, type: .content.__typename, title: .content.title, body: .content.body, url: .content.url, repo: .content.repository.nameWithOwner, fields: .fieldValues.nodes}
              | (
                  [ .fields[]
                    | select(.__typename=="ProjectV2ItemFieldSingleSelectValue")
                    | (.name // "" | gsub("^\\s+|\\s+$";"") | ascii_downcase)
                    | select(. != "" and ($sopts | index(.)))
                  ]
                ) as $status_vals
              | select(($status_vals | index("done")) != null)
              | (
                  [ .fields[]
                    | select(.__typename=="ProjectV2ItemFieldUserValue")
                    | (.users.nodes[]?.login // empty)
                  ] | unique
                ) as $assignees
              | {id, type, title, body, url, repo, assignees, fields}
              | @base64
            ' proj.json > items.b64

            declare -A P_BYTES=()
            declare -A P_FILES=()
            declare -A R_BYTES=()
            declare -A R_FILES=()
            declare -A DONE_SEEN=()
            DONE_UNIQ_BYTES=0
            DONE_UNIQ_FILES=0

            if [ ! -s items.b64 ]; then
              echo "No Done items found — $KEY"
            fi

            while read -r ROW; do
              [ -z "$ROW" ] && continue
              J=$(echo "$ROW" | base64 -d)
              TITLE=$(echo "$J" | jq -r '.title // ""' | tr '\r\n' ' ')
              BODY=$(echo "$J" | jq -r '.body // ""')
              TYPE=$(echo "$J" | jq -r '.type // ""')
              URL=$(echo "$J" | jq -r '.url // ""')
              REPO=$(echo "$J" | jq -r '.repo // ""')

              LINK=$(printf "%s\n" "$BODY" | grep -Eo 'https://github.com/[^ )]+' | head -n1 || true)
              if [ -z "$LINK" ]; then
                echo "Skip (no link) :: $TITLE"
                continue
              fi
              if ! echo "$LINK" | grep -qiE '\.(md|mdx)($|[?#])'; then
                echo "Skip (not md/mdx) :: $LINK"
                continue
              fi

              RAW_URL="$LINK"
              if echo "$LINK" | grep -q '/blob/'; then
                RAW_URL=$(printf "%s" "$LINK" | sed 's#https://github.com/#https://raw.githubusercontent.com/#; s#/blob/#/#')
              fi

              HDR=()
              if [ -n "${GH_TOKEN:-}" ]; then
                HDR=(-H "Authorization: Bearer ${GH_TOKEN}")
              elif [ -n "${GITHUB_TOKEN:-}" ]; then
                HDR=(-H "Authorization: Bearer ${GITHUB_TOKEN}")
              fi

              if ! curl -sSL "${HDR[@]}" "$RAW_URL" -o tmp.md; then
                echo "Fetch failed :: $RAW_URL"
                continue
              fi

              BYTES=$(wc -c < tmp.md | tr -d ' ')
              FILE_NAME=$(basename "$LINK")
              rm -f tmp.md

              if [ -z "${DONE_SEEN[$RAW_URL]+x}" ]; then
                DONE_SEEN[$RAW_URL]=1
                DONE_UNIQ_BYTES=$((DONE_UNIQ_BYTES + BYTES))
                DONE_UNIQ_FILES=$((DONE_UNIQ_FILES + 1))
              fi

              mapfile -t ASSIGNEES < <(echo "$J" | jq -r '.assignees[]?')
              # Fallback 1: Issue/PR assignees (API)
              if [ ${#ASSIGNEES[@]} -eq 0 ] && { [ "$TYPE" = "Issue" ] || [ "$TYPE" = "PullRequest" ]; }; then
                NUM=$(basename "$URL")
                if [ -n "$NUM" ] && [ -n "$REPO" ]; then
                  mapfile -t ASSIGNEES < <(gh api repos/"$REPO"/issues/"$NUM" --jq '.assignees[].login' 2>/dev/null || true)
                fi
              fi
              # Fallback 2: Text field named like Assignee(s)
              if [ ${#ASSIGNEES[@]} -eq 0 ]; then
                mapfile -t ASSIGNEES < <(echo "$J" | jq -r '
                  .fields[]?
                  | select(.__typename=="ProjectV2ItemFieldTextValue")
                  | select((.field.name // "" | test("(?i)assignee")))
                  | (.text // "")
                ' | tr '@' ' ' | tr ',' ' ' | tr '\n' ' ' | tr '\r' ' ' | tr ' ' '\n' | sed '/^$/d' | sort -u)
              fi
              if [ ${#ASSIGNEES[@]} -eq 0 ]; then
                ASSIGNEES=("unassigned")
              fi

              for A in "${ASSIGNEES[@]}"; do
                A=$(printf "%s" "$A" | tr -d '\r\n' | sed 's/^@//')
                [ -z "$A" ] && continue
                P_BYTES[$A]=$(( ${P_BYTES[$A]:-0} + BYTES ))
                P_FILES[$A]=$(( ${P_FILES[$A]:-0} + 1 ))
              done

              # Reviewer stats: custom field Reviewers(auto)
              RV_RAW=$(
                echo "$J" | jq -r '
                  [
                    .fields[]?
                    | select(.__typename=="ProjectV2ItemFieldTextValue")
                    | select((.field.name // "" | test("(?i)^reviewers\\s*\\(auto\\)\\s*$")))
                    | (.text // "")
                  ] | .[0] // ""
                ' | tr -d '\r'
              )
              if printf "%s" "$RV_RAW" | grep -q '@'; then
                mapfile -t REVIEWERS < <(
                  printf "%s" "$RV_RAW" \
                    | grep -Eo '@[A-Za-z0-9-]+' \
                    | sed 's/^@//' \
                    | sort -u
                )
              else
                mapfile -t REVIEWERS < <(
                  printf "%s" "$RV_RAW" \
                    | tr ',\n\t' ' ' \
                    | tr -s ' ' '\n' \
                    | sed 's/^@//' \
                    | grep -E '^[A-Za-z0-9-]+$' \
                    | sort -u
                )
              fi

              if [ ${#REVIEWERS[@]} -eq 0 ]; then
                REVIEWERS=("no-reviewer")
              fi
              for R in "${REVIEWERS[@]}"; do
                R=$(printf "%s" "$R" | tr -d '\r\n' | sed 's/^@//')
                [ -z "$R" ] && continue
                R_BYTES[$R]=$(( ${R_BYTES[$R]:-0} + BYTES ))
                R_FILES[$R]=$(( ${R_FILES[$R]:-0} + 1 ))
              done

              echo "Done :: $TITLE | $FILE_NAME | bytes=$BYTES | assignee(s)=$(printf "%s" "${ASSIGNEES[*]}")"
            done < items.b64

            if [ "$KEY" = "sui" ]; then
              if [ -z "${SUI_TOTAL_DOC_BYTES}" ]; then
                rm -rf _docs_repo_sui
                git clone --depth 1 --branch main https://github.com/Sui-Dev-Korea/sui.git _docs_repo_sui >/dev/null 2>&1 || true
                if [ -d "_docs_repo_sui/docs/content" ]; then
                  FIRST_DOC=$(
                    find _docs_repo_sui/docs/content -type f \( -name '*.md' -o -name '*.mdx' \) -print -quit 2>/dev/null || true
                  )
                  if [ -n "$FIRST_DOC" ]; then
                    SUI_TOTAL_DOC_BYTES=$(
                      find _docs_repo_sui/docs/content -type f \( -name '*.md' -o -name '*.mdx' \) -print0 2>/dev/null \
                        | xargs -0 wc -c 2>/dev/null \
                        | tail -n1 \
                        | awk '{print $1}' \
                        | tr -d ' ' || true
                    )
                  fi
                fi
                rm -rf _docs_repo_sui
              fi
              if [ -n "${SUI_TOTAL_DOC_BYTES}" ] && [ "${SUI_TOTAL_DOC_BYTES}" -gt 0 ] 2>/dev/null; then
                DONE_KB=$(awk "BEGIN { printf \"%.1f\", $DONE_UNIQ_BYTES/1024 }")
                TOTAL_KB=$(awk "BEGIN { printf \"%.1f\", $SUI_TOTAL_DOC_BYTES/1024 }")
                PROGRESS=$(awk "BEGIN { printf \"%.1f%%\", ($DONE_UNIQ_BYTES*100)/$SUI_TOTAL_DOC_BYTES }")
                printf '|%s|%s / %s|%s|\n' "$KEY" "$DONE_KB" "$TOTAL_KB" "$PROGRESS" >> "$PROGRESS_ROWS"
              fi
            fi

            if [ ${#P_BYTES[@]} -eq 0 ]; then
              printf '|%s|%s|%s|%s|%s|%s|\n' "$KEY" "-" "0" "0.0" "0" "0.0" >> "$ASSIGNEE_ROWS"
            else
              # Project totals
              TOTAL_BYTES=0
              TOTAL_FILES=0
              for USER in "${!P_BYTES[@]}"; do
                TOTAL_BYTES=$(( TOTAL_BYTES + ${P_BYTES[$USER]} ))
                TOTAL_FILES=$(( TOTAL_FILES + ${P_FILES[$USER]} ))
              done
              TOTAL_KB=$(awk "BEGIN { printf \"%.1f\", $TOTAL_BYTES/1024 }")
              printf '|%s|%s|%s|%s|%s|%s|\n' "$KEY" "TOTAL" "$TOTAL_FILES" "$TOTAL_KB" "$TOTAL_BYTES" "100.0" >> "$ASSIGNEE_ROWS"

              while read -r USER; do
                [ -z "$USER" ] && continue
                B=${P_BYTES[$USER]}
                F=${P_FILES[$USER]}
                KB=$(awk "BEGIN { printf \"%.1f\", $B/1024 }")
                SHARE=$(awk "BEGIN { if ($TOTAL_BYTES==0) print \"0.0\"; else printf \"%.1f\", ($B*100)/$TOTAL_BYTES }")
                printf '|%s|%s|%s|%s|%s|%s|\n' "$KEY" "$USER" "$F" "$KB" "$B" "$SHARE" >> "$ASSIGNEE_ROWS"
              done < <(printf "%s\n" "${!P_BYTES[@]}" | LC_ALL=C sort)
            fi

            if [ ${#R_BYTES[@]} -eq 0 ]; then
              printf '|%s|%s|%s|%s|%s|%s|\n' "$KEY" "-" "0" "0.0" "0" "0.0" >> "$REVIEWER_ROWS"
              echo "::endgroup::"
              continue
            fi

            R_TOTAL_BYTES=0
            for USER in "${!R_BYTES[@]}"; do
              R_TOTAL_BYTES=$(( R_TOTAL_BYTES + ${R_BYTES[$USER]} ))
            done

            while read -r USER; do
              [ -z "$USER" ] && continue
              B=${R_BYTES[$USER]}
              F=${R_FILES[$USER]}
              KB=$(awk "BEGIN { printf \"%.1f\", $B/1024 }")
              SHARE=$(awk "BEGIN { if ($R_TOTAL_BYTES==0) print \"0.0\"; else printf \"%.1f\", ($B*100)/$R_TOTAL_BYTES }")
              printf '|%s|%s|%s|%s|%s|%s|\n' "$KEY" "$USER" "$F" "$KB" "$B" "$SHARE" >> "$REVIEWER_ROWS"
            done < <(printf "%s\n" "${!R_BYTES[@]}" | LC_ALL=C sort)

            echo "::endgroup::"
          done < projects.txt

          if [ -s "$PROGRESS_ROWS" ]; then
            printf '## Progress\n\n' >> "$SUMMARY_OUT"
            printf '|Project|Done/Total (KB)|Progress|\n' >> "$SUMMARY_OUT"
            printf '|-|-|-|\n' >> "$SUMMARY_OUT"
            cat "$PROGRESS_ROWS" >> "$SUMMARY_OUT"
            printf '\n' >> "$SUMMARY_OUT"
          fi

          printf '## Done cards: md/mdx size by assignee\n\n' >> "$SUMMARY_OUT"
          printf '|Project|Assignee|Files|Total (KB)|Total (bytes)|Share (%%)|\n' >> "$SUMMARY_OUT"
          printf '|-|-|-|-|-|-|\n' >> "$SUMMARY_OUT"
          cat "$ASSIGNEE_ROWS" >> "$SUMMARY_OUT"

          printf '\n## Done cards: md/mdx size by reviewer (custom field)\n\n' >> "$SUMMARY_OUT"
          printf '|Project|Reviewer|Files|Total (KB)|Total (bytes)|Share (%%)|\n' >> "$SUMMARY_OUT"
          printf '|-|-|-|-|-|-|\n' >> "$SUMMARY_OUT"
          cat "$REVIEWER_ROWS" >> "$SUMMARY_OUT"

          cat "$SUMMARY_OUT" >> "$GITHUB_STEP_SUMMARY"
